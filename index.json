{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | Gaia Platform Documentation",
    "keywords": "API Reference Coming soon."
  },
  "articles/gaiac-ddl.html": {
    "href": "articles/gaiac-ddl.html",
    "title": "Gaiac and DDL | Gaia Platform Documentation",
    "keywords": "Gaiac and DDL NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. The Gaia Catalog Tool (gaiac) creates the datastore and tables that support your application. It also translates Gaia DDL files into the Gaia headers you include in your ruleset and app code files. Usage Usage:gaiac [options] [ddl_file]` Command line arguments Argument Description -d <dbname> Set the database name. -i Opens gaiac in interactive mode. For more information on the available commands, see the Interactive mode commands section below. -g Generate the Gaia headers and database tables for the specified ddl file. If the -d argument does not specify the database name, gaiac uses the ddl file name as the database name it creates. If the database does not exist, gaiac automatically creates it. If you do not specify a database name or a ddl file, the -o <path> Sets the output path for the generated header files. -h Print help information. <ddl file name> Specifies the ddl file from which to create database tables. If the -d argument does not specify the database name, gaiac uses the ddl file name as the database name it creates. If the database does not exist, gaiac automatically creates it. Interactive mode commands In the interactive mode the following commands are available: Command Description CREATE DATABASE [if not exists] DATABASE_NAME Creates a database with the specified database name. If the command succeeds, gaiac returns to the prompt. If the command fails, gaiac returns an error message and returns to the prompt. CREATE [if not exists] [DATA_BASE NAME.]TABLE ( <field definitions>) Creates a table with the specified name and fields. If the command succeeds, gaiac returns to the prompt. If the command fails, gaiac returns an error message and returns to the prompt. For more information on table specifications, see the CREATE TABLE section below. DROP DATABASE NAME Removes the database specified by NAME from the catalog. DROP TABLE [DATA_BASE NAME.]TABLE_NAME Removes the table specified by TABLE_NAME from the specified database specified by TABLE_NAME. If you do not specify a database, the default database '()' is assumed. \\h Print help information. \\dd [NAME] Lists the tables present in the database specified by NAME. If you do not specify a database, tables in the default database '()' are displayed. d[t] NAME Lists the fields and references in the table specified by NAME. \\ld [PATTERN] Lists the databases in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\lf [PATTERN] Lists the data fields in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\lr [PATTERN] Lists the relationships in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\l[t] [PATTERN] Lists the tables in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\q Quit Data Definition Language The Gaia DDL is similar to SQL since many of the platform features, such as tables, index, and constraints, map naturally to the similar or equivalent relational database features. CREATE TABLE Use the CREATE TABLE command to create a table. CREATE TABLE [if not exists] *table\\name* ( [ { *fieldname* *datatype* [, ... ] ] ) The following example creates a table named \"department.\" CREATE TABLE if not exists department ( name string,current bool active); Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, Gaia fires an Event that schedules the associated Declarative Rules to execute. REFERENCES Use the REFERENCES keyword to specify a foreign key constraint when creating tables. The following example creates a table named \"employee.\" The \"department\" field has a foreign key constraint pointing to the department. CREATE TABLE if not exists employee ( name string, department references department );"
  },
  "articles/gaia-glossary.html": {
    "href": "articles/gaia-glossary.html",
    "title": "Gaia Terminology | Gaia Platform Documentation",
    "keywords": "Gaia Terminology A Active Fields ( Rules Engine ) These are Database Column names that can be referred to in the body of a Declarative Rule expression. When any code in the system refers to one of these Fields with a read operation an Event ( defined below ) is generated to cause the associated Declarative Rule to be scheduled for execution. C Catalog D Declarative Chaining - Forward Chaining ( Rules Engine ) Declarative Chaining is a contract that defines specific automatic computation or transformation that is guaranteed by the system to occur as Fields, represented by nodes in the network, are modified. Forward Chaining describes the 'automatic' recomputation of the values of fields that have defined declarative relationships. When a Field with a declarative rule defined on it changes, at some point in processing****1***, the value of any dependent Fields are reevaluated based on the declarative rule's definition. This means that Forward Chaining can result in an open ended cascade of rule firing as the output from one declaratively defined Field is updated by the firing of other Field updates. Forward Chaining performs optimally on Fields that are updated infrequently where the resulting recomputed values are read frequently. Forward Chaining should be used instead of Backward Chaining in these cases. Declarative Rules ( Rules Engine ) Rules that are automatically fired by events when fields are updated. The definition of a declarative rule does not require a rule name, but must be annotated as declarative in some way. Upon entry Declarative Rules are parsed to generate the list of Fields that are referenced in the expression. The import and enabling of a Component containing declarative rules causes all referenced fields to be annotated in the schema as 'Active' fields. The field on the right side of the expression is also marked as read-only (for performance sake) since changing it would also immediately queue an event to reset its value. Declarative Rules should be designed to be as light-weight as possible. Forward Chaining allows breaking up complex relationships into multiple rules. E Edge ( Database ) Aliases: Link An edge captures a relationship between two Nodes. The edge metadata captures the type of the nodes that are linked as well as whether the edge is directional or not. An edge may also be thought of as a schematized list of properties. Event ( Rules Engine ) Describes <uany</u input to the system that we wish to use to trigger some form of processing, usually rules. Events can be generated from incoming sensor data, Database operations (like a commit), Field updates, pretty much anything we wish to attach to a processing action (a rule). Events are defined at the source of the change (a sensor's input stream, a schema entry) and a type of event. The event also names a rule that is to be fired when the specific type of event occurs. Ex: Database:Insert, Database:Commit, ML:Identified (a pic), (in the schema)Field x:changed, Sensor Y: Output-Available, etc. Events are managed by a subsystem of the Rules Engine. Extended Data Classes G Gaia Declarative Policy Platform Gaia Field Pointer ( Database ) A Gaia Field Pointer provides direct access to a field of a TrueGraphDB entity. Needs discussion about the implementation Gaia ID ( Database )** A persistent identifier of entities stored in TrueGraphDB (nodes and edges, not records). Internally, a Gaia ID maps to a locator, to allow access to its corresponding entity; this mapping is established at database startup or entity creation. Gaia Platform** [TBD] Gaia Pointer ( Database )** A Gaia Pointer is an opaque handle that can be used to reference a TrueGraphDB entity. It is implemented as a locator reference. L Locator (Database)** An in-memory entity reference. Internally, a locator is implemented as a slot id in a slot table that contains memory offsets. N Node ( Database ) A node is an entity container that can be involved in relationships represented by edges. A node may also be thought of as a schematized list of properties. Every node can be identified by its Gaia ID. Nodes could directly reference other nodes, for example, to form various data structures. P Policy Set R Record (Database) A record is a basic entity container. Unlike a Node, it cannot be referenced by edges or nodes. Rule ( Rules Engine ) Declarative Rules that are executed automatically in response to access or changes to the values of Fields that they contain references to. When Declarative Rules are created, they generate the metadata required to update the schema with the information required to cause the database to take note of when the associated Fields are changed, and provide the name of the defining Declarative Rule that will be triggered when Fields are accessed. Rule Author ( Rules Engine ) The user who is Authoring Rules to configure the system. Ruleset ( Rules Engine ) This is a logical container for a set of related rules to exist within. Rulesets are named & versioned. These containers will be used for importing and exporting blocks of rules, managing system updates. A Ruleset in an active system can be enabled or disabled; when disabled none of the rules within are visible or executable. Rules Engine ( Rules Engine ) The subsystem that handles the management, code generation and execution of rules. TrueGraphDB ( Database ) An in-memory, relational, graph-oriented, object database that also provides direct access to its entities/objects, which are nodes and edges of various types. Each entity can be seen as a record in the table represented by the collection of entities of the same type."
  },
  "articles/getting-started-with-gaia.html": {
    "href": "articles/getting-started-with-gaia.html",
    "title": "Getting Started with the Gaia Platform | Gaia Platform Documentation",
    "keywords": "Getting Started with the Gaia Platform NOTE At this time, Gaia Platform is in private preview. To request access, visit the developer page on the main Gaia Platform website and complete the request form at the bottom of the page. The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. This document provides guidance on setting up the Gaia SDK which includes the Gaia database server. Prerequisites Before you begin, make sure that you have the following prerequisites installed on your machine: Ubuntu Linux 18.04 or 20.04 Cmake build tools. The clang compiler version 8 or higher. A machine that supports the x86-64 architecture. If you don't currently have cmake and clang installed, you can use the following commands to install them: sudo apt update && sudo apt upgrade && sudo apt install cmake clang Download the Gaia package The Gaia SDK is delivered as a Debian software package (DEB). gaia-0.1.0_amd64.deb To download the package, use the time-limited URL that was sent to you in your welcome email. Install the package You must have sudo privileges to install the package. To install the package: Navigate to the folder that contains the downloaded package. At the command prompt, run the following command: sudo apt install ./gaia-0.1.0_amd64.deb To remove the package: At the command prompt, run the following command: sudo apt remove gaia To update the package, remove it and install the updated package: Download the updated package. Navigate to the folder that contains the downloaded package. To remove the currently installed package, run the following command: sudo apt remove gaia To install the new version, run the following command after replacing the x.y.z with the version number of the server that you are installing: sudo apt install ./gaia-<x.y.x>_amd64.deb Installed components /opt/gaia/bin gaia\\_db\\_server - The Gaia database catalog server. gaiac - Gaia Catalog compiler. gaiat - Gaia Translation Engine. /opt/gaia/etc gaia.conf - Contains configuration settings for the platform and application loggers that the Gaia Platform uses. Gaia\\_log.conf - Configuration settings for the database and rules engine that comprise the Gaia Platform. /opt/gaia/examples/incubator Incubator example /opt/gaia/include Include files for the Gaia Platform. /opt/gaia/lib Library files for the Gaia Platform. Start the Gaia server The Gaia server must be running to build or run any solution that is based on the Gaia Platform. We recommend that you don't run gaia_db_server under the root user, As with any daemon process that is accessible to the outside, running the Gaia server process as root, or any other account with special access rights, is a security risk. As best practice in production, run Gaia under a separate user account. This user account should only own the data that is managed by the server, and should not be used to run other daemons. For example, using the user nobody is not recommended. To prevent a compromised server process from modifying the Gaia executables, the user account must not own the Gaia executable files. The Gaia server supports two command line arguments: --data-dir <database-folder-path> specifies the location in which to store the Gaia database. --configuration-file-path <config-file-name> specifies the path and name of the configuration file that the Gaia server loads at startup. To start the server on a machine that supports systemd: sudo systemctl start gaia Starting the Gaia server on WSL When starting the Gaia server on WSL, use the --data-dir argument to specify the location in which to store the database. We recommend that you store it locally in ~/.local/gaia/db. To start the server on Ubuntu and run it in the background on WSL2 (Gaia has not been tested on WSL1): gaia_db_server --data-dir ~/.local/gaia/db & Build and run the incubator example You can verify that the Gaia SDK is installed properly by building and running the incubator demo. The source code for the incubator example is located in the /opt/gaia/examples/incubator folder. Note : If you encounter issues building and running the demo, the incubator folder contains a file named README.md. This document lists some of the common issues that you can encounter and suggested solutions. Before you can build the incubator example, you must run cmake to build the makefiles for the example. To run cmake against the supplied CMakeLists.txt file that is installed with the Package: Copy the incubator demo into your folder: cp -r /opt/gaia/examples/incubator . Navigate to the incubator demo folder: cd incubator To build and run the incubator example: Complete setup of the build environment by issuing the following commands: mkdir build cd build cmake .. make When the build finishes, use the following command to run the example: ./incubator sim Use the menu to start, stop, show, and access the other functions of the simulation. To monitor the incubator simulation, open another terminal window. Navigate to the build folder and run the following command: watch -n 1 ./incubator show This command displays the state of the incubators as well as the state of their associated sensors and fans. The status updates every second. Building a Gaia Platform solution After your design phase, the Gaia Platform architecture lends itself best to the following workflow: Create a schema for your application. The schema defines tables and fields that contain the state of your system at any given time. Add tables to manage the state of your application. Determine which columns in the schema drive the behavior. Your rules will act on these fields. In your makefile run gaiac to import the schema and create tables for your database. Gaiac generates a header that contains the edc classes that define your schema in code. You include in this header your ruleset definition file. Create your ruleset. Identify the actions to be performed when an Active Field changes. Run gaiat to translate the ruleset into code files that you in your app. Create your application and call the code supplied by gaiat. This is, of course, an iterative process. As you refine your application, you will make changes to the schema and ruleset. A good start is to add the input table with an Active Field, then add a ruleset that contains a rule that fires when rows are inserted. Build from there (iterate) with tables for output and managing the application's state. You define the schema in a DDL file. create table if not exists names ( name string active ); create table if not exists greetings ( greeting string active ); When you run gaiac, the composer creates the tables in the catalog and outputs header files that you include in your application. When designing your solution for the Gaia Platform, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation which means, two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. A rule must complete executing, which automatically commits its transaction before the actions resulting from the rule can be seen by the rest of the system. To state this another way: Rules run on separate threads. When data identified by an Active Field changes, it is possible for your app to check the database before rules based on the field run. Rules processing is atomic, a rule must complete before you can see the results of actions due to the changes. Rules only fire after the transaction that contains the change to the Active Field is committed. Said more succinctly, rules run post-commit. Next Steps Write your first Gaia App Learn the basics of creating rules"
  },
  "articles/rules-creation-basics.html": {
    "href": "articles/rules-creation-basics.html",
    "title": "Rules creation basics | Gaia Platform Documentation",
    "keywords": "Rules creation basics NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. Gaia extends C++ with declarative programming functionality. These declarative extensions couple directly with Gaia’s in-memory database, where you can model your application’s state and data. When the data changes, declarative policies are immediately dispatched to trigger high-speed, responsive behavior. The Gaia Platform fires rules in response to database events. Rules are bound to the tables and Active Fields defined in your schema. Your procedural code is where the transactions occur that fire the rules you define, and you must commit the transaction before the rule will fire. When writing your declarative code, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation. Two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. Before the rest of the system can the actions resulting from the rule can be seen, the rule must exit to commit the transaction. To state this another way: Rules run on separate threads. When data identified by an Active Field changes, your app can check the database before rules based on the field run. Rules processing is atomic. A rule must complete before you can see the results of actions due to the changes. Important : Be careful with the use of objects that have a shared mutable state, such as static variables. There are no protections in place to prevent all the usual race conditions, timing, and visibility issues common in other procedural programming. In short, all multithreading best practices apply when dealing with procedural code. The true power of rules comes from the fact that they simplify the code required to realize your application. Active Fields Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, code generated by Gaia subscribes the rule to all changes to that field. Whenever the active field is updated and committed, Gaia fires an Event that schedules the associated Declarative Rules to execute. When the Rule is executed, the row that was operated on is delivered to the rule as an automatic parameter. You can specify which fields are active in two ways: By prepending an @ symbol to the field: if (@person.location == some_location) ... By specifying fields in an OnUpdate or OnChange attribute: OnChange(person.location){ ... } NOTE : These two methods of specifying the active fields in a rule are mutually exclusive. If you inadvertently mix them, gaiat notifies you with the following error message: \"Since a rule attribute was provided, specifying active fields inside the rule is not supported.\" If your rule is simple, using the @ symbol is an easy way to visually identify which fields are active and where they are used. If your rule is more complex, keeping track of the active fields using the @ identifier method can become confusing. In this case, identifying all of the Active Fields using an 'On' attribute keeps your rules cleaner and allows you to identify all of the active fields at a glance. Active Fields specified by prepending the @ symbol create a subscription by reading the field. There are several ways to use an Active Field to read it's value create the subscription to the rule: Use it in a conditional statement. For example: if (@person.location == some_location) ... Pass it as a parameter to another function. Read it or write to it. For example, read the Active Field named location so that we can append \"...\" to it and then write the updated value: @person.location += \"...\" When the rules use the OnUpdate or OnChange attributes to specify the Active Fields, the subscription to changes is created whether or not you use the field in the rule. This is useful when you need to perform an action but do not need the value of changed column. Acting on inserts to a table To specify that your rule fires when a new record is inserted in the table, use the OnInsert attribute. The following rule snippet watches for an insert into the names table: OnInsert(names) { ... } Forward chaining of events A compelling design concept of applications written in Gaia is the idea of “forward chaining.” forward chaining occurs when the firing of one rule results in a change to the state of the database that immediately fires the firing of a subsequent rule. Creating a ruleset Rules are simple, grouped by named blocks called “rulesets”. Rulesets are typically contained in files with extension .ruleset. They are written using special Gaia Declarative Syntax extensions to C++ (and other host languages in the future). This is composed of a modified version of C++ code that includes ways to refer directly to fields in the database in novel and powerful ways. Note : Do not modify these files directly. If you need to update the rules, modify the .ruleset file and run gaiat again. The following template shows the basic format of a ruleset declaration. ruleset <namespace> { { //body of rule } { //body of rule } … } The following ruleset declaration is from the Hello sample included with the Gaia SDK. ruleset hello_ruleset { // Rule 1: Whenever a name is inserted, // insert a new greeting into the greetings table. OnInsert(names) { // Form the greeting using the name. string new_greeting = \"Hello \" + string(names.name) + \"!\"; // Insert the greeting. gaia::hello::greetings_t::insert_row(new_greeting.c_str()); } // Rule 2: Whenever a greeting is inserted, // output it to the console. OnInsert(greetings) { // Output the greeting to the console. cout << endl << greetings.greeting << endl; } } In this simple example the ruleset is driven by events on two tables: names and greetings. Each table has a single field and that field has been defined as Active: names.name and greetings.greeting. When a process inserts a name into the names table, Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule #1. The rule checks to see if it was an insert operation. If it was an insert operation, the rule inserts a new row into the greetings table. Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule #2. This is an example of forward chaining. The first rule causes a change in state to the database, a row insertion, that fires the second rule. When a process updates and commits name to the greetings table, the rules engine is notified by the database that a change has occurred. The rules engine receives a pointer to the exact row that changed. The pointer references an id that specifies the entities affected. In code you can retrieve this id by calling the gaia_id() method. The Gaia ID provides the changed row in the context for the rule's execution. Using the Gaia ID your rule can retrieve the object that fired the rule to perform operations on it using the EDC API. Analyzing your rules Rule Statistics The rules engine logs statistics according to settings in the `gaia.conf` configuration. The following options determining logging behavior: Option Default if Unspecified Description stats_log_interval 10 seconds The interval in seconds for how frequently the rules engine logs statistics. All stats (counts, averages, etc) are calculated anew for each interval. log_individual_rule_stats False If set to true, then in addition to rollup statistics for all rules, the same statistics are calculated for each rule. Here is sample output when of the rule_stats log when individual rule statistics are not collected: 2020-11-30T15:15:37 30026 <rules_stats>;: ------------------------- sched invoc pend aband retry excep avg lat max lat avg exec max exec 2020-11-30T15:15:37 30026 <rules_stats>;: thread load: 0.49 % 21 21 0 0 0 0 15.26 ms 23.59 ms 1.46 ms 9.31 ms 2020-11-30T15:15:47 30026 <rules_stats>;: thread load: 0.65 % 30 30 0 0 0 0 13.66 ms 19.66 ms 0.28 ms 7.01 ms For example, the first data row shows that 21 rules were scheduled and 21 rules were invoked. If individual rule statistics are turned on, sample output might look like: 2020-11-30T15:13:25 28975 <rules_stats>: ------------------------- sched invoc pend aband retry excep avg lat max lat avg exec max exec 2020-11-30T15:13:25 28975 <rules_stats>: thread load: 0.73 % 28 28 0 0 0 1 15.11 ms 24.91 ms 0.74 ms 10.61 ms 2020-11-30T15:13:25 28975 <rules_stats>;: incubator_ruleset::1_sensor 27 27 0 0 0 1 15.25 ms 24.91 ms 0.77 ms 10.61 ms 2020-11-30T15:13:25 28975 <rules_stats>;: incubator_ruleset::3 1 1 0 0 0 0 11.30 ms 11.30 ms 0.01 ms 0.01 ms Here we see that of the 28 scheduled/invocations in this time interval, the rules engine invoked incubator_ruleset::1_sensor 27 times and incubator_ruleset::3 once. Rule Tracing To display the rules traces to the console, edit your gaia_log.conf file and add the following entry: logger name = \"rules\" sinks = \"console\", \"file_rotating\" level = \"trace\" Sample output from on console will appear similar to the following: 2020-11-30T15:35:33-08:00 trace 30862 30878 &lt;rules&gt;: call: incubator_ruleset::1_sensor 2020-11-30T15:35:33-08:00 trace 30862 30874 &lt;rules&gt;: call: incubator_ruleset::1_sensor 2020-11-30T15:35:33-08:00 trace 30862 30878 &lt;rules&gt;: return: incubator_ruleset::1_sensor 2020-11-30T15:35:33-08:00 trace 30862 30874 &lt;rules&gt;: return: incubator_ruleset::1_sensor Note that the first number following \"trace\" is the process id. The second number is the thread id. If an exception occurs, the tracing displays output similar to the following: 2020-11-30T15:46:34-08:00 trace 31036 31068 &lt;rules&gt;: exception: incubator_ruleset::2, The rules engine has not been initialized yet."
  },
  "articles/templates/baggageadvisor-template.html": {
    "href": "articles/templates/baggageadvisor-template.html",
    "title": "Gaia Baggage Advisor template | Gaia Platform Documentation",
    "keywords": "Gaia Baggage Advisor template NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. Gaia Platform is a low-code programming environment for applications at the edge. The Baggage Advisor template provides a complete application that demonstrates how Gaia interacts with other systems such as ROS2 and how Gaia's low-code rules can make development faster and more approachable. Baggage Advisor's job is to provide supervisory guidance to humans working to deliver passengers their baggage. The motivation behind the Gaia Baggage Advisor template is the need to quickly and efficiently update core business logic for custom versions of the business logic, perhaps at a different airport. By placing Gaia Platform at the center of this application, you can make these modifications faster, saving time and other integration costs. Prerequisites Gaia SDK (available by request) ROS2 Foxy. For information about installing ROS2 Foxy, see Installing ROS 2 via Debian Packages on the ROS2 documentation site. Hardware: A camera connected to the host computer (typically mounted at /dev/video0) Installing the template The Gaia Baggage Advisor template follows the canonical ROS2 workspace setup and build process. The installation process assumes that you have installed ROS2 foxy and have followed the steps to initialize rosdep . The Gaia Baggage Advisor repository includes: Source code for the Gaia Baggage Advisor template Source code for the ROS2 data exchange with the camera QR codes representing the assets needed to run a demonstration scenario The repository containing the template is available on GitHub: https://github.com/gaia-platform/baggage_advisor_template To install the Gaia Baggage Advisor template run the following commands: ~$ mkdir -p ~/ros2_ws/src && cd ~/ros2_ws/src ~/ros2_ws/src$ git clone git@github.com:gaia-platform/baggage_advisor_template.git ~/ros2_ws/src$ cd ~/ros2_ws ~/ros2_ws$ source /opt/ros/foxy/setup.bash ~/ros2_ws$ rosdep install --from-paths src --ignore-src -r -y ~/ros2_ws$ colcon build ~/ros2_ws$ source install/local_setup.bash Scenario When the application is running, the barcode scanner reads image streams from a physical camera and sends messages with the identified code to other components. The main Baggage Advisor component receives barcode messages into its database which causes interaction with the Gaia rules engine The UI then displays the live video feed with visual overlays indicating the application’s status. The relevant concepts in this scenario are as follows: Loading area , represented as a barcode. This is where carts are to be loaded. Carts , represented as a barcode. When a cart obscures the underlying packing area, the Baggage Advisor app knows it's time to load the cart. Manifest , represented in the database. When a cart is detected, it is paired with an as-yet-unfulfilled manifest. Manifests list the quantity and types of different packages to be loaded on the cart. bag, represented as a barcode. The bag can be of a type and is requested in a certain quantity. In this example, you won’t need to have access to an airport or even a special-purpose camera to see how Gaia can interact with cameras and UIs over ROS2 middleware or to get a good sense of how Gaia rules drive the application’s behavior. Rather, you can make use of the included barcodes (printed on paper) and any camera connected to your computer. Once the application is running, just show the codes to your camera. There’s even a script you can follow below. How it works Baggage Advisor works by consuming data from a stationary camera feed and identifying barcodes that indicate the presence of different items (i.e. carts, bag, the loading area itself). In a production setting, the camera is mounted in a fixed location and monitors the loading area. As barcodes are detected, they are sent as ROS2 messages to the Gaia Platform module. Gaia low-code rules dictate the next step in the process or identify errors for the human operator to respond to. The following state diagram shows the decisions that take place when the application detects a barcode. The primary actions are setting states in the Gaia database and sending messages that indicate the meaning of those states to the UI. Loading area barcode read. Is there a current manifest being fulfilled? There is no manifest being fulfilled. The current manifest is not complete. Cart barcode read. There are no more manifests to fulfill. There is a manifest that needs fulfilling. Bag barcode read. There are no more manifests to fulfill. There is no manifest being fulfilled. Current Manifest is already complete Item already fulfilled in manifest Item completes the manifest Unknown barcode Do nothing. The Gaia Baggage Advisor template breaks this behavior into simple, concise rules that fire when the data is updated in the Gaia database. Fig. ‘New Code Seen’ State Machine Rules Gaia low-code or declarative rules work in conjunction with the Gaia database. When a rule references an Active Field in the database, an update to that field causes the Gaia rule to execute. Before looking at the rules, you should review the structure of the database. The database is defined in the Baggage Advisor.ddl file located in the gaia_control/src/ folder. The template defines seven declarative rules to implement the entire application's business logic or 'mission.' These rules are implemented in the Baggage Advisor.ruleset file located in the gaia_control/src folder. You can look at these rules and their comments to get a sense of how they work and what fields cause them to fire. Data changes to a field that is referred to in a rule cause the rule to execute. There are two ways to set up this functionality. One way is to prepend the name of a field with the “@” symbol. Think of this as setting that field to an Active Field. The other is to wrap the body of the rule with an OnUpdate(fieldname) expression. You will see examples of both in this ruleset. Finally, a quick overview of the rules and the data they react to make it easier to see how rules and data fields interconnect: // The camera sees a new code // // Reacts to: camera.camera_data_code // Changes: // cart_area.last_cart_id // cart_area.current_cart_id // cart_area.current_baggage_id // camera.camera_data_code // // A cart has moved onto or off of a cart area // // Reacts to: cart_area.current_cart_id // Changes: // Creates: cart // // If last_cart_id changes, check if the cart's manifest was fully loaded // before it moves off the cart area // // Reacts to: cart_area.last_cart_id // Changes: // // A bag has moved onto a cart area. Create the associated baggage row // and reset the current_baggage_id field. // // Reacts to: cart_area.current_baggage_id // Changes: cart_area.current_baggage_id // Creates: baggage // // A bag has moved onto a cart area, and this rule checks if the baggage is // not in the current cart's manifest or if there is no manifest on the cart. // // Reacts to: cart_area.current_baggage_id // // A bag has moved onto a cart area, and this rule checks if there is no cart // in the cart area to put a bag onto. // // Reacts to: cart_area.current_baggage_id // // A bag has been added to a manifest // // Reacts to: baggage.LastOperation // Changes: manifest.actual_qty // // Check if manifest is full // // Reacts to: manifest.actual_qty // Changes: manifest.state // // Check if manifest line item is over full // // Reacts to: manifest_baggage.actual_qty // Changes: // Rule Chaining When the value of an Active Field of the database changes, the Gaia rules engine automatically fires the rule. When a rule is fired, it can in turn change additional fields. If those fields are designated as active in a rule, the rules engine will fire the associated rules. We call this forward chaining . The combination of rules firing automatically and then cascading to the execution of other rules is the basis for the declarative system. The following figure shows process flow as implemented in the Gaia ruleset with forward chaining: Fig. Chaining Path This approach simplifies the diagram, providing an easier to understand and follow representation of the process flow. NOTE : The complexity of the relationships might be more complex than shown in the chaining table because rules can use non-active fields in addition to active fields to change system state. Demonstration Scenario The demonstration simulates an airport baggage handling facility. It uses a single camera to read Barcodes that represent three object types: Loading area Carts Bags The manifests and other system scenario data are created each time you run the application. In total, eight barcodes are presented to the camera in sequence. One loading area Three carts Three bags One object of unknown type The barcodes are provided in the qr_codes.pdf which is located in the demo_assets of the Baggage Advisor template repository. The three manifests have line items as follows: Manifest 1: bag: A, qty: 1 Manifest 2: bag: A, qty: 1 bag: B, qty: 1 Manifest 3: bag: C, qty: 3 Scenario Sequence To observe this template in operation, run the following command: ~/ros2_ws$ ros2 launch gaia_control baggage_advisor.launch.py video_device:=/dev/video0 Now that the application is running, a window will appear. Select the refresh icon in the top-left and then select the webcam/image_marked topic. You are now ready to start presenting the included barcode files to the camera in the following sequence. Runtime scenario 1: Show loading area Show cart 1 Show bag A Indicate remove cart operation Runtime scenario 2: Show blank Show bag A Error is indicated: too many packages Runtime scenario 3: Show loading area Show cart 2 Show bag A Show bag B Indicate remove cart operation Runtime scenario 4: Show loading area Show cart 3 Show bag A Error is indicated: package not in manifest Runtime scenario 5: Show bag C Show blank Show bag C Show loading area An error is indicated: manifest not complete Runtime scenario 6: Show unknown object Error is indicated"
  },
  "articles/templates/index.html": {
    "href": "articles/templates/index.html",
    "title": "Templates overview | Gaia Platform Documentation",
    "keywords": "Templates overview Comming soon: Gaia templates provide you with an opportunity to experiment with the platform in the context of complete, real-world inspired applications. They are a great way to learn about how Gaia connects with other software systems and give you a chance to experiment by extending their functionality."
  },
  "articles/tutorials/gaia-incubator-example.html": {
    "href": "articles/tutorials/gaia-incubator-example.html",
    "title": "Gaia incubator example | Gaia Platform Documentation",
    "keywords": "Gaia incubator example NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. The following example models an incubator system for chickens and puppies. It simulates temperature sensors and cooling fans. The simulation has two distinct components: A simulator component that models the environment and a Gaia component that controls the incubators' behavior in response to changes. As the simulation runs, you will notice that the temperature in both incubators tends to increase. To counteract the environment getting too hot for the young animals, the Gaia component invokes logic to turn on the fans. Prerequisites For information about the Gaia Platform prerequisites and installing the SDK, see Getting Started with the Gaia Platform . Preparing the demo To copy the incubator demo into your current directory: cp -r /opt/gaia/examples/incubator/ . Navigate to the incubator demo folder: cd incubator If the Gaia database server is not running, start it now. To start the server on a machine that supports systemd: sudo systemctl start gaia Complete setup of the build environment by issuing the following commands: mkdir build cd build cmake .. make The incubator demo The example includes the following files: CMakeLists.txt - Build instructions for setting up the necessary files for the example. gaia.conf - Configuration settings for the database and rules engine that comprise the Gaia Platform. gaia_log.conf - configuration settings for the platform and application loggers that the Gaia Platform uses. incubator.ddl - Describes the schema to create the database. incubator.ruleset - Defines the rules definitions for the example. Main.cpp - The incubator application that drives the simulation. README.md - Information about the example and troubleshooting instructions. Running the demo is the next thing to do to see what it does, then we can explain how it works. Running the incubator It is helpful to Have a couple of terminal windows running to see what happens 'in real time.' First, open two terminal windows. You will run the demo in one and monitor it in the other. In your first terminal window, run the command: ./incubator sim When the demo starts, it displays the following menu: To start the simulation, select b . In the second terminal window, run the command: watch -n .5 ./incubator show This command dumps the contents of the incubators' state and their sensors and fans to the screen. The output will appear similar to the following: The output shows the incubator and components being monitored. For each of the temperature sensors and fan actuators, the output displays a timestamp in the second column and the current temperature or fan actuator speed in the third column. As the simulation runs, the temperature in both incubators tends to increase. To counteract the environment getting too hot for your chickens and puppies, Gaia invokes logic to turn on the fan actuators. Let's look at how this is accomplished. How the incubator demo works The core Gaia files that you need to examine are the incubator.ddl and incubator.ruleset files. First, let's examine the data store. The schema is located in the incubator.ddl and it defines three tables. incubator - Models the incubator. actuator - Models the fans. sensor - Models the temperature sensor. In Gaia the fields defined in the data definition file are considered potentially Active. This means that the Gaia rules engine executes rules when you refer to the field in the rule. You have two ways to specify which fields are active: Use the OnUpdate() or OnChange() attribute to list the active fields in the rule. OnUpdate(field1, field2, field3) Prepend an @ sign to the fields that are Active. @field1 = ... The incubator.ruleset file defines the logic that acts on the Active Fields. This file contains several Gaia rules in the ruleset. The first rule is defined as follows: OnUpdate(sensor.value, incubator.max_temp, incubator.min_temp) { if (!incubator.is_on) { return; } if (sensor.value >= incubator.max_temp) { actuator.value = min(c_fan_speed_limit, actuator.value + c_fan_speed_increment); actuator.timestamp = g_timestamp; } else if (sensor.value <= incubator.min_temp) { actuator.value = max(0.0f, actuator.value - (2*c_fan_speed_increment)); actuator.timestamp = g_timestamp; } } The rule uses the OnUpdate() attribute to watch for changes to the sensor.value, incubator.max_temp, incubator.min_temp fields. The second if block tells Gaia to check if a value field in the sensor table is greater or equal than the max_temp field in the incubator table. If this is true, then it means that the incubator is too hot, and we need to turn on the fan actuator. We do this by assigning a new value to the actuator table, as seen in the if block's body. You can see this behavior carried out by starting the simulation. When the temperature sensors exceed the maximum temperature value, the fan actuator value changes from 0 to 500. The rule fires whenever the temperature value changes, which means that the fan actuator might increase its speed several times. It can even increase fast enough to drive the temperature of the incubator below the specified minimum value. But this is okay. The else if block in the ruleset contains the necessary logic to reduce the fan actuator speed if it falls below the minimum temperature. Additionally, since the Gaia Platform understands your schema and how your tables are related, the rule is reading all the sensors' values in each incubator and setting the value for all the actuators in each incubator. In this example, each incubator is related to a set of sensors and actuators. So far, we've focused on changes to the sensor.value field. But we also have an incubator.max_temp or incubator.min_temp field. What if we wanted to change the temperature range of our incubator? Would Gaia be able to respond to this as well? The answer is yes. In this example, sensor.value, incubator.max_temp, and incubator.min_temp are all Active Fields. The simulation environment lets us test the link between the Active Fields in the ruleset. For this example, you will manage one of the incubators, setting the temperature range to a new value. To set the new value: Start the simulation. To manage the incubators, select m . To manage the puppies incubator, select p . To drive the execution of the rule described above, set the new max_temp value to one that is less than the current sensor value. For example, if the puppy incubator temperature is reading 92, set the max_temp value to 90. Now, when you monitor the incubators, you will see that Gaia increments the fan actuator values when the temperature exceeds the new maximum temperature. Before submitting the new max_temp, your tables should look like this. After you submit the new max value, both fan actuators associated with the incubator immediately start increasing their speed, like so: This application of the rule functions on the same principle as in the first example. The difference is that the change that triggers the rule is caused by our intervention rather than the changes driven by the environment. In the first example, changes in sensor.value caused the rule to fire and to compare the updated sensor.value against the current value of max_temp. In this example, you changed the value of max_temp which caused the rule to fire and compare the current value sensor.value against the updated value of max_temp. It is also worth observing that in this case, more than one fan actuator was associated with the incubator and both fan actuators had their speeds increased. The way that we have defined our Gaia data tables means actuators refer back to the incubator. Gaia is aware of this connection and can apply fan actuator increase logic to all the actuators associated with the puppies incubator. There is one more concept to review. So far, we have explored changes that come either from the ambient environment or direct user intervention. But a compelling design concept for writing programs in Gaia is the idea of \"forward chaining.\" This is when the firing of one rule can result in a change to state that immediately triggers the firing of a subsequent rule. Rule 3 in the the ruleset file illustrates this functionality: // Rule 3: If the fan is at 70% of its limit and the temperature is still too hot then // set the fan to its maximum speed. OnUpdate(actuator.value) { if (actuator.value == c_fan_speed_limit) { return; } if (actuator.value > c_fan_threshold * c_fan_speed_limit && sensor.value > incubator.max_temp) { actuator.value = c_fan_speed_limit; } } The comment preceding the rule describes its purpose. If the fan actuators have been ratcheting up to counteract a hot incubator, there comes a point when we do not want to wait for further incremental increases. Instead, we max out the fan actuator's speed. The first if block acts as a simple guard where the second encodes the real logic. There are several variables in the conditional. The primary active variable is the actuator.value field. This means that changes to the fan actuator speed trigger the rule. You will also notice two other variables from the prior rule, sensor.value and incubator.max_temp. However, these fields are not listed in the OnUpdate() attribute and therefore do not cause the rule to fire. We can now review how the first rule and the just-introduced rule will interact. As you recall, the first rule is triggered by a change in the sensor.value field and results in the modification of the actuator.value field. This change now immediately causes Gaia to check the conditions described in Rule 3. This is forward chaining in action. To see this behavior, return to the simulation controller and allow the incubator to heat up considerably beyond its maximum temperature. To do this, after starting the simulation, select manage incubators from the menu, select an incubator and enter the command to turn off the power. This forces the incubator to stop actuating the fans (allowing the environment to heat up). Wait until the temperature of the incubator exceeds the maximum temperature range by a few degrees. When it does, enter the command to turn the incubator power back on. The associated fan actuator speed values start climbing in increments of 500. When the fan actuator speed reaches 3500, there is a jump to 5000 - a sudden change of 1500. This sudden jump is caused by the firing of rule 1 modifying the actuator.value (fan actuator speed) which triggers the immediate firing of rule 3. Use forward chaining to build out complex application behavior."
  },
  "articles/tutorials/writing-first-gaia-application.html": {
    "href": "articles/tutorials/writing-first-gaia-application.html",
    "title": "Writing your first Gaia application | Gaia Platform Documentation",
    "keywords": "Writing your first Gaia application NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. In this walkthrough, you'll write and run your first Gaia Platform application. The code that you will write is also available under the /opt/gaia/examples/hello folder of the distribution package. If you encounter any errors along the way, you can compare the files that you generated from these instructions against those already provided. The example walks you through most aspects of the Gaia Platform system.You'll learn how to: Define a database schema and compile it with the Gaia Catalog Tool (gaiac). Write a few simple rules and translate them using the Gaia Translation Engine (gaiat). Write, build, and execute a simple application to trigger our rules by inserting data into the database. Prerequisites For information about the Gaia Platform prerequisites and installing the SDK, see Getting Started with the Gaia Platform . This walkthrough assumes that you are using Clang 10. The Hello application The goal of the application is to generate greetings for input names. To demonstrate the features of the system, the code inserts names into a table, which triggers a rule that generates greetings for those names and inserts them into a second table. The insertions into the second table trigger a second rule that prints the greetings to the console. For this purpose, there are two tables: A names table with a single name column, of string type. A greetings table with a single greeting column, of string type. There are also two rules: A rule that triggers on insertions into the names table and that will in turn form and insert a greeting into the greetings table. A rule that triggers on insertions into the greetings table and prints the greeting values to the console. To put all of this together, you'll also write a small application that inserts some names into the names table to trigger the rules. Creating a new application folder Create a new folder in which to store the files for the application. mkdir hello_sample cd hello_sample You'll execute all of the commands specified in this document in this folder. Specifying the Hello database schema If you are familiar with SQL syntax the Gaia DDL definition format will be familiar to you. In your source folder, create a hello.ddl text file. Copy and paste the following definitions in it: create table if not exists names ( name string ); create table if not exists greetings ( greeting string ); The statements define the two tables, names and greetings *, that that application uses. Each table has one database column. You will refer to the database column names in the body of Declarative Rule expressions that you will define later. When your declarative code refers to one of these Fields with a read operation, Gaia triggers an Event that schedules the associated Declarative Rules for execution. The next step is to compile the definitions and generate the tables in the Gaia database. To do this, you use the gaiac tool. At the command line, in the folder in which you created the hello.ddl file, run the following command: gaiac -g hello.ddl Gaiac prints a message that tells you where it wrote the gaia_hello.h file. This file contains definitions necessary to programmatically interact with the tables that are generated based on the definitions. You will see these referred to as Extended Data Classes, or EDC, for short. Gaiac generates a second file name hello_generated.h. This is included by the gaia_hello. h file; you will not reference this file directly. To verify that the tables were successfully created, run gaiac in an interactive mode: gaiac -i At the prompt, type the following command to list all the database tables. l You should see two rows for the names and greetings tables. The other entries are for system catalog tables or other tables that you might have generated with other examples. The entries that you are interested in are listed last and look similar to the following: Database Name ID Type ... ... ... ... hello names 48 1 hello greetings 50 1 Do not worry if the ID values or the Type values look different the important thing is to see the tables listed. To exit the interactive gaiac session, use the following command: exit Specifying the Hello rules Create a new file and name it hello.ruleset. Copy and paste the following content to it: ///////////////////////////////////////////// // Copyright (c) Gaia Platform LLC // All rights reserved. ///////////////////////////////////////////// #include <iostream> #include <string> #include \"gaia_hello.h\" using namespace std; ruleset hello_ruleset { // Rule 1: Whenever a name is inserted, // insert a new greeting into the greetings table. OnInsert(names) { // Form the greeting using the name. string new_greeting = \"Hello \" + string(names.name) + \"!\"; // Insert the greeting. gaia::hello::greetings_t::insert_row(new_greeting.c_str()); } // Rule 2: Whenever a greeting is inserted, // output it to the console. OnInsert(greetings) { // Output the greeting to the console. cout << endl << greetings.greeting << endl; } } The ruleset file defines two rules. The rules use the OnInsert() attribute to watch for insertions to the names and greetings tables. To insert the greeting into the greetings table, you use the gaia::hello::greetings_t::insert_row method. You can find the signature for the method in the gaia_hello.h file that gaiac generated. Finally, the second rule outputs the greeting to the console. The rules code looks very much like C++ but, before you can compile it, you must translate it into proper C++ code using the Gaia translator tool - gaiat. To generate C++ code for these rules, execute the following command: gaiat hello.ruleset -output hello_ruleset.cpp -- -I /usr/lib/clang/10/include/ -I /opt/gaia/include/ NOTE : The two include paths of this command might need to be updated if Gaia and clang are installed in a non-standard way or if you're using a version of Clang other than 10. The output of this step is the hello_rules.cpp that contains the C++ version of our rules. You are now ready to compile these into an application. Writing the Hello application Create a new file and name it hello.cpp. Copy and paste the following code into it: #include <iostream> #include \"gaia/system.hpp\" #include \"gaia_hello.h\" using namespace std; int main() { cout << \"Hello example is running...\" << endl; gaia::system::initialize(); gaia::db::begin_transaction(); gaia::hello::names_t::insert_row(\"Alice\"); gaia::hello::names_t::insert_row(\"Bob\"); gaia::hello::names_t::insert_row(\"Charles\"); gaia::db::commit_transaction(); gaia::system::shutdown(); cout << \"Hello example has shut down.\" << endl; } Let's go over the main steps of this code: gaia::system::initialize() initializes the Gaia system. The insertion of the names needs to be done within a transaction that starts with gaia::db::begin_transaction() and completes with gaia::db::commit_transaction() . The actual insertions use the generated gaia::hello::names_t helper from gaia_hello.h. The application completes its execution by calling gaia::system::shutdown() , which is the counterpart to the gaia::system::initialize() call. To build this code, use the following command: clang++-10 hello.cpp hello_ruleset.cpp /usr/local/lib/libgaia.so -I /opt/gaia/include -Wl,-rpath,/usr/local/lib -lpthread -o hello If you are using a newer version of the clang compiler or if Gaia is installed in a non-standard location, update the command accordingly. The output is a hello executable which represents your Hello application. Executing the Hello application You are now ready to execute the app: ./hello You should see output that looks similar to the following: Hello example is running... Hello Bob! Hello Alice! Hello Charles! Hello example has shut down. The order in which the rules are triggered is not deterministic. Due to this, the output of the program will vary from run to run."
  },
  "index.html": {
    "href": "index.html",
    "title": "About the Gaia Platform | Gaia Platform Documentation",
    "keywords": "About the Gaia Platform The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. Overview Gaia Platform is a software development framework that makes it easier to program autonomous systems at the edge. Gaia empowers programmers to make use of low-code features while still being appropriate for industrial use cases. Combining a high-speed in memory database with declarative C++ language extensions, Gaia provides a performant and intuitive model for development. Model your state in the database, and when things change, your declarative application logic will respond automatically. As a developer, you can focus on what your program needs to do and let Gaia work out how it gets done. With Gaia, you’ll write less code that’s easier to read and more intuitive to debug and test. You can integrate multiple system components in a common setting with less boilerplate, from machine learning functions to ROS-enabled actuators. And you can run it all without the need for constant cloud connectivity. In a phrase, Gaia Platform is the industrial-strength low-code development environment for apps at the edge. Why Gaia? Writing software is complicated. As you look to develop autonomous systems that need to operate reliably and intelligently out in the real world, you can find that the difficulty has only increased. There's a lot to get working and a lot of moving pieces to integrate. For example, machine learning has come a long way, but it takes more than obstacle detection to build an interesting product. Plus, these systems generate a ton of data we need to deal with, which results in lots of code that’s hard to debug and even harder to maintain over its lifetime. Gaia exists to overcome these challenges. The Gaia Platform is data-centric and responsive, like the world of autonomous machines. It is the nexus for integrating all the distributed components comprising your autonomous system and orchestrating their behavior to deliver on your mission's objectives. Are you looking for a way to accelerate the development of a new IoT prototype? Do you have subject matter experts with lots of knowledge and limited coding experience? What about a complex robotics product with an unwieldy state-machine? Or maybe you’re a hobbyist developer looking to play around with a Donkey Car but are frustrated by all the low-level details and just want an easier way to \"make it do this thing!\" In all of these cases, Gaia can help. How can you use Gaia? The Gaia Platform supports numerous application scenarios with a common theme of operating in complex scenarios at the edge. Gaia’s database and policies can be used to inform the behavior of an application directly. Write policies to respond to specific scenarios as informed by data (state) in the Gaia database. For example, you’re building an Autonomous Guided Vehicle (AGV) to move material around a warehouse. You can use Gaia’s database to model inventory and waypoint data so that your AGV can work without a direct connection to the internet. Throughout its mission, your AGV might generate lots of interesting and frankly uninteresting data. Use Gaia’s DB to store it for the moment and implement data fusion and filtering logic with Gaia policies. You can write a policy that throws away intermediate navigation data but retains any discoveries about the location of inventory. At the end of the mission, your AGV can sync back only what’s critical so that you can save on cloud bandwidth and storage costs. In systems in which pair Machine Learning (ML) and Deep Learning (DL) with perception and action planning methods, the Gaia Platform provides robust rules handling and event messaging to understand the data. What does this mean for Autonomous Systems? Autonomous Systems typically engage in a process of perceiving their environment, understanding an operational context, and acting accordingly. ML/DL is excellent at turning data into meaningful semantics, such as examining an RBG tensor and producing a label like \"kitty!\". To go from \"I see the kitty\" to \"I will pet the kitty\" requires additional layers of software to take the data from the perception engine and contextualize its output to make the decision. This is where Gaia comes in. Gaia allows you to define all the logic that contextualizes these inputs, understand the situation, and translate it into a decision. Based on the decision, Gaia can raise an event that sends an instruction to the robotic arm to pet the kitty. Beyond applications in Autonomous Systems, Gaia provides an Industrial strength transactional store that supports a transactionally safe framework. Whatever happens, you will always have a consistent database from which you can share data and act on it robustly. How it works Gaia is a platform in the sense that users build their applications on top of its functionality. Gaia runs on the Linux operating system and supports C++ and (soon) Python programming languages with declarative functionality. Gaia's in-memory database is installed with the platform and enables seamless integration between database operations and application control code. The Gaia Platform consists of the following elements: A shared in memory database An events engine A Catalog that interfaces with your app, the events engine, and the database And provides the following tools: Gaia Catalog compiler. The catalog compiler creates the datastore and tables that support your application. It also translates Gaia DDL files into the Gaia headers you include in your ruleset and app code files. For more information, see Gaiac and DDL . Gaia Translation Engine. The translation engine converts your rulesets into code files that you include in your app. These components and tools interact to create an end-to-end solution. To accomplish this, Gaia addresses the PUA paradigm: Perceive, Understand, and Act. In Gaia, this is expressed as: Perceive - Where inputs come from Understand - Gaia platform Act - Rules engine policies/ integration with devices Perceive Your procedural code gathers the data from the inputs and writes them the Gaia database. Gaia itself is not focused on direct control of the actions you take to control and read devices such as microcontrollers. This includes: Interrupt Processing Device Drivers Fine-grained manipulation of actuators Etc. The Database is Active. This means that it functions as an Event system that monitors the incoming changes to the database and publishes them for subscribed rules. The Gaia platform implements the database as an in memory high-performance data store. For more information about defining your Gaia database, see Gaiac and DDL . Understand The primary focus of rules is the Policy layer of applications. You define rules using easy-to-read and understand declarative code. The declarative code that defines a rule takes the form of \"If this happens, then do that.\" The rules engine and database work together to facilitate: Adaptive responses and process diversion resolution. For example, handle route diversion when a drone air taxi encounters bad weather. Data-driven decision-making. For example, Is this person allowed to be in that room at this hour. If you find edge cases where you need just a bit more control, you can intermix declarative code (rules) with procedural code. For more information about defining your rules, see Rules creation basics . Act Your code acts on the data and decisions produced by your rules. Gaia integrates with other platforms such as ROS2, including lower-level motion planning systems and other features to interact with your hardware. With Gaia, you can send a high-level instruction \"go to this waypoint\" to a ROS2 node that handles the task of navigating to that location. Summary Gaia provides a catalog that binds the database to the Gaia rules engine. Rules are written in declarative code and enable event-driven processing. The declarative code binds the rules to changes in the database without complex control flow logic. Next Steps Get started with the Gaia Platform Write your first Gaia App Learn the basics of creating rules"
  }
}