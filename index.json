{
  "articles/gaiac-ddl.html": {
    "href": "articles/gaiac-ddl.html",
    "title": "Gaiac and DDL | Gaia Platform Documentation",
    "keywords": "Gaiac and DDL NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. The Gaia Catalog Tool (gaiac) creates the datastore and tables that support your application. It also translates Gaia DDL files into the Gaia headers you include in your ruleset and app code files. Usage Usage:gaiac [options] [ddl_file]` Command line arguments Argument Description -d <dbname> Set the database name. -i Opens gaiac in interactive mode. For more information on the available commands, see the Interactive mode commands section below. -g Generate the Gaia headers and database tables for the specified ddl file. If the -d argument does not specify the database name, gaiac uses the ddl file name as the database name it creates. If the database does not exist, gaiac automatically creates it. If you do not specify a database name or a ddl file, the -o <path> Sets the output path for the generated header files. -h Print help information. <ddl file name> Specifies the ddl file from which to create database tables. If the -d argument does not specify the database name, gaiac uses the ddl file name as the database name it creates. If the database does not exist, gaiac automatically creates it. Interactive mode commands In the interactive mode the following commands are available: Command Description CREATE DATABASE [if not exists] DATABASE_NAME Creates a database with the specified database name. If the command succeeds, gaiac returns to the prompt. If the command fails, gaiac returns an error message and returns to the prompt. CREATE [if not exists] [DATA_BASE NAME.]TABLE ( <field definitions>) Creates a table with the specified name and fields. If the command succeeds, gaiac returns to the prompt. If the command fails, gaiac returns an error message and returns to the prompt. For more information on table specifications, see the CREATE TABLE section below. DROP DATABASE NAME Removes the database specified by NAME from the catalog. DROP TABLE [DATA_BASE NAME.]TABLE_NAME Removes the table specified by TABLE_NAME from the specified database specified by TABLE_NAME. If you do not specify a database, the default database '()' is assumed. \\h Print help information. \\dd [NAME] Lists the tables present in the database specified by NAME. If you do not specify a database, tables in the default database '()' are displayed. d[t] NAME Lists the fields and references in the table specified by NAME. \\ld [PATTERN] Lists the databases in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\lf [PATTERN] Lists the data fields in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\lr [PATTERN] Lists the relationships in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\l[t] [PATTERN] Lists the tables in the Gaia catalog. Optionally, you can filter the results by specifying a regex pattern. For more information on regex, see ECMAScript syntax on the cplusplus.com website. \\q Quit Data Definition Language The Gaia DDL is similar to SQL since many of the platform features, such as tables, index, and constraints, map naturally to the similar or equivalent relational database features. CREATE TABLE Use the CREATE TABLE command to create a table. CREATE TABLE [if not exists] *table\\name* ( [ { *fieldname* *datatype* [ *active* ] [, ... ] ] ) The following example creates a table named \"department.\" CREATE TABLE if not exists department ( name string,current bool active); Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, Gaia triggers an Event that schedules the associated Declarative Rules to execute. REFERENCES Use the REFERENCES keyword to specify a foreign key constraint when creating tables. The following example creates a table named \"employee.\" The \"department\" field has a foreign key constraint pointing to the department. CREATE TABLE if not exists employee ( name string, department references department );"
  },
  "articles/gaia-glossary.html": {
    "href": "articles/gaia-glossary.html",
    "title": "Gaia Terminology | Gaia Platform Documentation",
    "keywords": "Gaia Terminology A Active Fields ( Rules Engine ) These are Database Column names that can be referred to in the body of a Declarative Rule expression. When any code in the system refers to one of these Fields with a read operation an Event ( defined below ) is generated to cause the associated Declarative Rule to be scheduled for execution. C Catalog D Declarative Chaining - Forward Chaining ( Rules Engine ) Declarative Chaining is a contract that defines specific automatic computation or transformation that is guaranteed by the system to occur as Fields, represented by nodes in the network, are modified. Forward Chaining describes the 'automatic' recomputation of the values of fields that have defined declarative relationships. When a Field with a declarative rule defined on it changes, at some point in processing****1***, the value of any dependent Fields are reevaluated based on the declarative rule's definition. This means that Forward Chaining can result in an open ended cascade of rule firing as the output from one declaratively defined Field is updated by the firing of other Field updates. Forward Chaining performs optimally on Fields that are updated infrequently where the resulting recomputed values are read frequently. Forward Chaining should be used instead of Backward Chaining in these cases. Declarative Rules ( Rules Engine ) Rules that are automatically fired by events when fields are updated. The definition of a declarative rule does not require a rule name, but must be annotated as declarative in some way. Upon entry Declarative Rules are parsed to generate the list of Fields that are referenced in the expression. The import and enabling of a Component containing declarative rules causes all referenced fields to be annotated in the schema as 'Active' fields. The field on the right side of the expression is also marked as read-only (for performance sake) since changing it would also immediately queue an event to reset its value. Declarative Rules should be designed to be as light-weight as possible. Forward Chaining allows breaking up complex relationships into multiple rules. E Edge ( Database ) Aliases: Link An edge captures a relationship between two Nodes. The edge metadata captures the type of the nodes that are linked as well as whether the edge is directional or not. An edge may also be thought of as a schematized list of properties. Event ( Rules Engine ) Describes <uany</u input to the system that we wish to use to trigger some form of processing, usually rules. Events can be generated from incoming sensor data, Database operations (like a commit), Field updates, pretty much anything we wish to attach to a processing action (a rule). Events are defined at the source of the change (a sensor's input stream, a schema entry) and a type of event. The event also names a rule that is to be fired when the specific type of event occurs. Ex: Database:Insert, Database:Commit, ML:Identified (a pic), (in the schema)Field x:changed, Sensor Y: Output-Available, etc. Events are managed by a subsystem of the Rules Engine. Extended Data Classes G Gaia Declarative Policy Platform Gaia Field Pointer ( Database ) A Gaia Field Pointer provides direct access to a field of a TrueGraphDB entity. Needs discussion about the implementation Gaia ID ( Database )** A persistent identifier of entities stored in TrueGraphDB (nodes and edges, not records). Internally, a Gaia ID maps to a locator, to allow access to its corresponding entity; this mapping is established at database startup or entity creation. Gaia Platform** [TBD] Usage: Proper capitalization? Gaia Platform vs Gaia platform. Gaia Pointer ( Database )** A Gaia Pointer is an opaque handle that can be used to reference a TrueGraphDB entity. It is implemented as a locator reference. Needs discussion about the implementation Usage: Both words capitalized. L Locator (Database)** An in-memory entity reference. Internally, a locator is implemented as a slot id in a slot table that contains memory offsets. N Node ( Database ) A node is an entity container that can be involved in relationships represented by edges. A node may also be thought of as a schematized list of properties. Every node can be identified by its Gaia ID. Nodes could directly reference other nodes, for example, to form various data structures. P Policy Set R Record (Database) A record is a basic entity container. Unlike a Node, it cannot be referenced by edges or nodes. Rule ( Rules Engine ) Declarative Rules that are executed automatically in response to access or changes to the values of Fields that they contain references to. When Declarative Rules are created, they generate the metadata required to update the schema with the information required to cause the database to take note of when the associated Fields are changed, and provide the name of the defining Declarative Rule that will be triggered when Fields are accessed. Rule Author ( Rules Engine ) The user who is Authoring Rules to configure the system. Ruleset ( Rules Engine ) This is a logical container for a set of related rules to exist within. Rulesets are named & versioned. These containers will be used for importing and exporting blocks of rules, managing system updates. A Ruleset in an active system can be enabled or disabled; when disabled none of the rules within are visible or executable. Rules Engine ( Rules Engine ) The subsystem that handles the management, code generation and execution of rules. TrueGraphDB ( Database ) An in-memory, relational, graph-oriented, object database that also provides direct access to its entities/objects, which are nodes and edges of various types. Each entity can be seen as a record in the table represented by the collection of entities of the same type."
  },
  "articles/getting-started-with-gaia.html": {
    "href": "articles/getting-started-with-gaia.html",
    "title": "Getting Started with the Gaia Platform | Gaia Platform Documentation",
    "keywords": "Getting Started with the Gaia Platform NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. This document provides guidance on setting up the Gaia SDK which includes the Gaia database server. Prerequisites Before you begin, make sure that you have the following prerequisites installed on your machine: Ubuntu Linux 18.04 or 20.04 Cmake build tools. The clang compiler version 8 or higher. A machine that supports the x86-64 architecture. If you don’t currently have cmake and clang installed, you can use the following commands to install them: sudo apt update && apt upgrade && apt install cmake clang1 Download the Gaia package The Gaia SDK is delivered as a Debian software package (DEB). gaia-0.1.0_amd64.deb To download the package, use the time-limited URL that was sent to you in your welcome email. Install the package You must have sudo privileges to install the package. To install the package: Navigate to the folder that contains the downloaded package. At the command prompt, run the following command: sudo apt install ./gaia-0.1.0_amd64.deb To remove the package: At the command prompt, run the following command: sudo apt remove gaia To update the package, remove it and install the updated package: Download the updated package. Navigate to the folder that contains the downloaded package. Remove the currently installed package by running the following command: sudo apt remove gaia At the command prompt, run the following command: sudo apt install ./gaia-<x.y.x>_amd64.deb Installed components /opt/gaia/bin gaia\\_db\\_server - The Gaia database catalog server. gaiac - Gaia Catalog compiler. gaiat - Gaia Translation Engine. /opt/gaia/etc gaia.conf - Contains configuration settings for the platform and application loggers that the Gaia Platform uses. Gaia\\_log.conf - Configuration settings for the database and rules engine that comprise the Gaia Platform. /opt/gaia/examples/incubator Incubator example /opt/gaia/include Include files for the Gaia Platform. /opt/gaia/lib Library files for the Gaia Platform. Start the Gaia server The Gaia server must be running to build or run any solution that is based on the Gaia Platform. We recommend that you don’t run gaia_db_server under the root user, As with any daemon process that is accessible to the outside, running the Gaia server process as root, or any other account with special access rights, is a security risk. As best practice in production, run Gaia under a separate user account. This user account should only own the data that is managed by the server, and should not be used to run other daemons. For example, using the user nobody is not recommended. To prevent a compromised server process from modifying the Gaia executables, the user account must not own the Gaia executable files. To start the server on a machine that supports systemd: sudo systemctl start gaia To start the server on Ubuntu running on WSL2 (not tested on WSL1): gaia_db_server & Build and run the incubator example You can verify that the Gaia SDK is installed properly by building and running the incubator demo. The source code for the incubator example is located in the /opt/gaia/examples/incubator_demo folder. Note : If you encounter issues building and running the demo, the incubator_demo folder contains a file named README.md. This document lists some of the common issues that you can encounter and suggested solutions. Before you can build the incubator example, you must run cmake to build the makefiles for the example. To run cmake against the supplied CMakeLists.txt file that is installed with the Package: Copy the incubator demo into your folder: cp -r /opt/gaia/examples/incubator . Navigate to the incubator demo folder: cd incubator To build and run the incubator example: Complete setup of the build environment by issuing the following commands: mkdir build cd build cmake .. make When the build finishes, use the following command to run the example: ./incubator sim Use the menu to start, stop, show, and access the other functions of the simulation. To monitor the incubator simulation, open another terminal window and run the following command: watch -n 1 ./incubator show This command displays the state of the incubators as well as the state of their associated sensors and fans. The status updates every second. Building a Gaia Platform solution After your design phase, the Gaia Platform architecture lends itself best to the following workflow: Create a schema for your application. The schema defines tables and fields that contain the state of your system at any given time. Add tables to manage the state of your application. Determine which columns in the schema drive the behavior. Your rules will act on these fields. In your makefile run gaiac to import the schema and create tables for your database. Gaiac generates a header that contains the edc classes that define your schema in code. You include in this header your ruleset definition file. Create your ruleset. Identify the actions to be performed when an Active Field changes. Run gaiat to translate the ruleset into code files that you include in your app. Create your application and call the code supplied by gaiat. This is, of course, an iterative process. As you refine your application, you will make changes to the schema and ruleset. A good start is to add the input table with an Active Field, then add a ruleset that contains a rule that fires when rows are inserted. Build from there (iterate) with tables for output and managing the application’s state. You define the schema in a DDL file. create table if not exists names ( name string active ); create table if not exists greetings ( greeting string active ); When you run gaiac, the composer creates the tables in the catalog and outputs header files that you include in your application. When designing your solution for the Gaia Platform, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation which means, two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. A rule must complete executing, which automatically commits its transaction before the actions resulting from the rule can be seen by the rest of the system. To state this another way: Rules run on separate threads. When data identified by an Active Field changes, it is possible for your app to check the database before rules based on the field run. Rules processing is atomic, a rule must complete before you can see the results of actions due to the changes. Rules only fire after the transaction that contains the change to the Active Field is committed. Said more succinctly, rules run post-commit."
  },
  "articles/rules-creation-basics.html": {
    "href": "articles/rules-creation-basics.html",
    "title": "Rules creation basics | Gaia Platform Documentation",
    "keywords": "Rules creation basics NOTE The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. Gaia extends C++ with declarative programming functionality. These declarative extensions couple directly with Gaia’s in-memory database, where you can model your application’s state and data. When the data changes, declarative policies are immediately dispatched to trigger high-speed, responsive behavior. The Gaia Platform fires rules in response to database events. Rules are bound to the tables and Active Fields defined in your schema. Your procedural code is where the transactions occur that trigger the rules you define and you must commit the transaction before the rule will fire. When writing your declarative code, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation which means, two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. Before the actions resulting from the rule can be seen by the rest of the system the rule must exit to commit it’s transaction. To state this another way: Rules run on separate threads. When data identified by an Active Field changes, it is possible for your app to check the database before rules based on the field run. Rules processing is atomic, a rule must complete before you can see the results of actions due to the changes. Important : Be careful with the use of objects that have a shared mutable state, such as static variables. There are no protections in place to prevent all the usual race conditions, timing, and visibility issues common in other procedural programming. In short, all multithreading best practices apply when dealing with procedural code. The true power of rules comes from the fact that with this syntax they simplify the code required to realize your application. Operations on Active Fields Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, code generated by Gaia subscribes the rule to all changes to that field. Whenever the active field is updated and committed, Gaia triggers an Event that schedules the associated Declarative Rules execute. When the Rule is executed, the row that was operated on is delivered to the rule as an automatic parameter. To create a subscription to a rule, your rule must read an Active Field that you have defined in your DDL. There are several ways to use an Active Field to read it’s value to trigger the rule: Use it in a conditional statement. For example: if (person.location == some_location) ... Pass it as a parameter to another function. Read it or write to it. For example: person.location += \"...\" The example statement reads the Active Field named location so that we can append \"...\" to it and then it writes the updated value. Reading an active field without triggering a rule There are times that you might need to read an Active Field but you don’t want to trigger rules that are based on that Field. For example, you might want to include the Field in a calculation that shouldn’t fire associated rules. To prevent the read operation from triggering rules, prepended the Field with an @ symbol. savedLocation = @person.location; This suppresses the Active behavior of the Field in the rule. Use LastOperation to watch for changes to a table The Gaia Platform implements the LastOperation property on tables to provide a way for your Declarative Code to react to any change to a table. Your Declarative Rule can monitor a table for the following events: INSERT, UPDATE, and DELETE. For example, if you include a condition on <table>.LastOperation == UPDATE then the rule fires if any field changes in a record in the specified table. The following rule snippet watches for an insert into the names table: if (names.LastOperation == INSERT) { ... } Forward chaining of events A compelling design concept of applications written in Gaia is the idea of “forward chaining.” forward chaining occurs when the firing of one rule results in a change to the state of the database that immediately triggers the firing of a subsequent rule. Creating a ruleset Rules are simple, grouped by named blocks called “rulesets”. Rulesets are typically contained in files with extension .ruleset. They are written using special Gaia Declarative Syntax extensions to C++ (and other host languages in the future). This is composed of a modified version of C++ code that includes ways to refer directly to fields in the database in novel and powerful ways. Note: Do not modify these files directly. If you need to update the rules, modify the .ruleset file and run gaiat again. The following template shows the basic format of a ruleset declaration. ruleset <namespace> { { //body of rule } { //body of rule } … } The following ruleset declaration is from the Hello sample included with the Gaia SDK. ruleset hello_ruleset { // Rule 1: Whenever a name is inserted, // insert a new greeting into the greetings table. { // This LastOperation reference indicates to Gaia // that this rule should be triggered // by any insertion made into the names table. if (names.LastOperation == INSERT) { // Form the greeting using the name. string new_greeting = \"Hello \" + string(names.name) + \"!\"; // Insert the greeting. gaia::hello::greetings_t::insert_row(new_greeting.c_str()); } } // Rule 2: Whenever a greeting is inserted, // output it to the console. { // This LastOperation reference indicates to Gaia // that this rule should be triggered // by any insertion made into the greetings table. if (greetings.LastOperation == INSERT) { // Output the greeting to the console. cout << endl << greetings.greeting << endl; } } } In this simple example the ruleset is driven by events on two tables: names and greetings. Each table has a single field and that field has been defined as Active: names.name and greetings.greeting. When a process inserts a name into the names table, Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule #1. The rule checks to see if it was an insert operation. If it was an insert operation, the rule inserts a new row into the greetings table. Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule # 2. This is an example of forward chaining. The first rule causes a change in state to the database, a row insertion, that triggers the second rule. When a process updates and commits name to the greetings table, the rules engine is notified by the database that a change has occurred. The rules engine receives a pointer to the exact row that changed. The pointer references an id that specifies the entities affected. In code you can retrieve this id by calling the gaia_id() method. The Gaia ID provides the changed row in the context for the rule’s execution. Using the Gaia ID your rule can retrieve the object that triggered the rule to perform operations on it using the EDC API. Analyzing your rules Rule Statistics The rules engine logs statistics according to settings in the `gaia.conf` configuration. The following options determining logging behavior: Option Default if Unspecified Description stats_log_interval 10 seconds The interval in seconds for how frequently the rules engine logs statistics. All stats (counts, averages, etc) are calculated anew for each interval. log_individual_rule_stats False If set to true, then in addition to rollup statistics for all rules, the same statistics are calculated for each rule. Here is sample output when of the rule_stats log when individual rule statistics are not collected: [2020-11-30T15:15:37] [30026] <rules_stats>: ------------------------- sched invoc pend aband retry excep avg lat max lat avg exec max exec [2020-11-30T15:15:37] [30026] <rules_stats>: [thread load: 0.49 %] 21 21 0 0 0 0 15.26 ms 23.59 ms 1.46 ms 9.31 ms [2020-11-30T15:15:47] [30026] <rules_stats>: [thread load: 0.65 %] 30 30 0 0 0 0 13.66 ms 19.66 ms 0.28 ms 7.01 ms For example, the first data row shows that 21 rules were scheduled and 21 rules were invoked. If individual rule statistics are turned on, sample output might look like: [2020-11-30T15:13:25] [28975] <rules_stats>: ------------------------- sched invoc pend aband retry excep avg lat max lat avg exec max exec [2020-11-30T15:13:25] [28975] <rules_stats>: [thread load: 0.73 %] 28 28 0 0 0 1 15.11 ms 24.91 ms 0.74 ms 10.61 ms [2020-11-30T15:13:25] [28975] <rules_stats>: incubator_ruleset::1_sensor 27 27 0 0 0 1 15.25 ms 24.91 ms 0.77 ms 10.61 ms [2020-11-30T15:13:25] [28975] <rules_stats>: incubator_ruleset::3 1 1 0 0 0 0 11.30 ms 11.30 ms 0.01 ms 0.01 ms Here we see that of the 28 scheduled/invocations in this time interval, incubator_ruleset::1_sensor was invoked 27 times and incubator_ruleset::3 was invoked 1 time. Rule Tracing One can also enable tracing of rules to the console by changing the trace level of the rules logger to \"trace\". editing their gaia_log.conf file. Adding the following entry to the gaia_log.conf file will turn on rule specific tracing: [[logger]] name = \"rules\" sinks = [ \"console\", \"file_rotating\" ] level = \"trace\" Sample output from the console looks like: [2020-11-30T15:35:33-08:00] [trace] [30862 30878] <rules>: call: incubator_ruleset::1_sensor [2020-11-30T15:35:33-08:00] [trace] [30862 30874] <rules>: call: incubator_ruleset::1_sensor [2020-11-30T15:35:33-08:00] [trace] [30862 30878] <rules>: return: incubator_ruleset::1_sensor [2020-11-30T15:35:33-08:00] [trace] [30862 30874] <rules>: return: incubator_ruleset::1_sensor Note that the first number following \"[trace]\" is the process id. The second number is the thread id. If an exception occurs, the tracing displays output similar to the following: 2020-11-30T15:46:34-08:00] [trace] [31036 31068] <rules>: exception: incubator_ruleset::2, The rules engine has not been initialized yet."
  },
  "articles/templates/index.html": {
    "href": "articles/templates/index.html",
    "title": "Templates overview | Gaia Platform Documentation",
    "keywords": "Templates overview Coming soon."
  },
  "articles/tutorials/writing-first-gaia-application.html": {
    "href": "articles/tutorials/writing-first-gaia-application.html",
    "title": "Prerequisites | Gaia Platform Documentation",
    "keywords": "The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. In this walkthrough, you’ll write and run your first Gaia Platform application. The code that you will write is also available under the /opt/gaia/examples/hello folder of the distribution package. If you encounter any errors along the way, you can compare the files that you generated from these instructions against those already provided. The example walks you through most aspects of the Gaia Platform system. You’ll learn how to: Define a database schema and compile it with the Gaia Catalog Tool (gaiac). Write a few simple rules and translate them using the Gaia Translation Engine (gaiat). Write, build, and execute a simple application to trigger our rules by inserting data into the database. Prerequisites For information about the Gaia Platform prerequisites and installing the SDK, see Getting Started with the Gaia Platform . The Hello application The goal of the application is to generate greetings for input names. To demonstrate the features of the system, the code inserts names into a table, which triggers a rule that generates greetings for those names and inserts them into a second table. The insertions into the second table trigger a second rule that prints the greetings to the console. For this purpose, there are two tables: A names table with a single name column, of string type. A greetings table with a single greeting column, of string type. There are also two rules: A rule that triggers on insertions into the names table and that will in turn form and insert a greeting into the greetings table. A rule that triggers on insertions into the greetings table and prints the greeting values to the console. To put all of this together, you’ll also write a small application that inserts some names into the names table to trigger the rules. Creating a new application folder Create a new folder in which to store the files for the application. mkdir hello_sample cd hello_sample You’ll execute all of the commands specified in this document in this folder. Specifying the Hello database schema In your source folder, create a hello.ddl text file. Copy and paste the following definitions in it: create table if not exists names ( name string active ); create table if not exists greetings ( greeting string active ); If you are familiar with SQL syntax this definition format should be familiar. The statements define the two tables, names and greetings *,* that our application uses. The keyword active is new and is specific to Gaia. Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, Gaia triggers an Event that schedules the associated Declarative Rules execute. The next step is to compile the definitions and generate the tables in the Gaia database. To do this you use the gaiac tool. At the command line, in the folder in which you created the hello.ddl file, run the following command: gaiac -g hello.ddl gaiac prints a message that tells you where it wrote the gaia_hello.h file. This file contains definitions necessary to programmatically interact with the tables that are generated based on the definitions. You will see these referred to as Extended Data Classes, or EDC, for short. Gaiac generates a second file name hello_generated.h. This is included by the gaia_hello. h file; you will not reference this file directly. To verify that the tables were successfully created, run gaiac in an interactive mode: gaiac -i At the prompt, type the following command to list all the database tables. l You should see two rows for the names and greetings tables. The other entries are for system catalog tables or other tables that you might have generated with other examples. The entries that you are interested in are listed last and look similar to the following: Database Name ID Type ... ... ... ... hello names 48 1 hello greetings 50 1 Do not worry if the ID values or the Type values look different the important thing is to see the tables listed. To exit the interactive gaiac session, use the following command: exit Specifying the Hello rules Create a new file and name it hello.ruleset. Copy and paste the following content to it: #include <iostream> #include <string> #include \"gaia_hello.h\" using namespace std; ruleset hello_ruleset { // Rule 1: Whenever a name is inserted, // insert a new greeting into the greetings table. { // This LastOperation reference will indicate to the system // that this rule should be triggered // by any insertion made into the names table. if (names.LastOperation == INSERT) { // Form the greeting using the name. string new_greeting = \"Hello \" + string(names.name) + \"!\"; // Insert the greeting. gaia::hello::greetings_t::insert_row(new_greeting.c_str()); } } // Rule 2: Whenever a greeting is inserted, // output it to the console. { // This LastOperation reference will indicate to the system // that this rule should be triggered // by any insertion made into the greetings table. if (greetings.LastOperation == INSERT) { // Output the greeting to the console. cout << endl << greetings.greeting << endl; } } } The ruleset file defines two rules. Updates to the names table trigger the first rule. - this is caused by the rule simply referencing names.LastOperation . Because we’re only interested in acting on insert operations, the rule specifically checks that the last operation is an insert. INSERT is a system constant. To insert the greeting that we constructed into the greetings table, we use the gaia::hello::greetings_t::insert_row method that was generated in the gaia_hello.h file by gaiac, when we compiled the table declarations. Finally, the second rule outputs the greeting to the console. The rules code looks very much like C++ but, before you can compile it, you must translate it into proper C++ code using the Gaia translator tool - gaiat. To generate C++ code for these rules, execute the following command: gaiat hello.ruleset -output hello_rules.cpp -- -I /usr/lib/clang/8/include/ -I /opt/gaia/include/ NOTE : The two include paths of this command might need to be updated if Gaia and clang have been installed in a non-standard way or if you’re using a version of Clang other than 8. The output of this step is the hello_rules.cpp that contains the C++ version of our rules. You are now ready to compile these into an application. Writing the Hello application Create a new file and name it hello.cpp. Copy and paste the following code into it: #include <iostream> #include \"gaia/system.hpp\" #include \"gaia_hello.h\" using namespace std; int main() { cout << \"Hello example is running...\" << endl; gaia::system::initialize(); gaia::db::begin_transaction(); gaia::hello::names_t::insert_row(\"Alice\"); gaia::hello::names_t::insert_row(\"Bob\"); gaia::hello::names_t::insert_row(\"Charles\"); gaia::db::commit_transaction(); gaia::system::shutdown(); cout << \"Hello example has shut down.\" << endl; } Let’s go over the main steps of this code: gaia::system::initialize() initializes the Gaia system. The insertion of the names needs to be done within a transaction that we start with gaia::db::begin_transaction() and complete with gaia::db::commit_transaction() . The actual insertions use the generated gaia::hello::names_t helper from gaia_hello.h. Our application completes its execution by calling gaia::system::shutdown(), which is the counterpart to our gaia::system::initialize() call. To build this code, use the following command: clang++-8 hello.cpp hello_rules.cpp /usr/local/lib/libgaia.so -I /opt/gaia/include -Wl,-rpath,/usr/local/lib -o hello -lpthread If you are using a newer version of the clang compiler or if Gaia is installed in a non-standard location, update this command accordingly. Its result should be a hello executable, which represents our Hello application. Executing the Hello application You are now ready to execute the app: ./hello You should see output that looks similar to the following: Hello example is running... Hello Bob! Hello Alice! Hello Charles! Hello example has shut down. The order in which the rules get triggered is not deterministic. This is why the output of the program will vary from run to run."
  },
  "index.html": {
    "href": "index.html",
    "title": "About the Gaia Platform | Gaia Platform Documentation",
    "keywords": "About the Gaia Platform The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability. Overview Gaia Platform is a software development framework that makes it easier to program autonomous systems at the edge. Gaia empowers programmers to make use of low-code features while still being appropriate for industrial use cases. Combining a high-speed in memory database with declarative C++ language extensions, Gaia provides a performant and intuitive model for development. Model your state in the database, and when things change, your declarative application logic will respond automatically. As a developer, you can focus on what your program needs to do and let Gaia work out how it gets done. With Gaia, you’ll write less code that’s easier to read and more intuitive to debug and test. You can integrate multiple system components in a common setting with less boilerplate, from machine learning functions to ROS-enabled actuators. And you can run it all without the need for constant cloud connectivity. In a phrase, Gaia Platform is the industrial-strength low-code development environment for apps at the edge. Why Gaia? Writing software is complicated. As you look to develop autonomous systems that need to operate reliably and intelligently out in the real world, you can find that the difficulty has only increased. There's a lot to get working and a lot of moving pieces to integrate. For example, machine learning has come a long way, but it takes more than obstacle detection to build an interesting product. Plus, these systems generate a ton of data we need to deal with, which results in lots of code that’s hard to debug and even harder to maintain over its lifetime. Gaia exists to overcome these challenges. The Gaia Platform is data-centric and responsive, like the world of autonomous machines. It is the nexus for integrating all the distributed components comprising your autonomous system and orchestrating their behavior to deliver on your mission's objectives. Are you looking for a way to accelerate the development of a new IoT prototype? Do you have subject matter experts with lots of knowledge and limited coding experience? What about a complex robotics product with an unwieldy state-machine? Or maybe you’re a hobbyist developer looking to play around with a Donkey Car but are frustrated by all the low-level details and just want an easier way to \"make it do this thing!\" In all of these cases, Gaia can help. How can you use Gaia? The Gaia Platform supports numerous application scenarios with a common theme of operating in complex scenarios at the edge. Gaia’s database and policies can be used to inform the behavior of an application directly. Write policies to respond to specific scenarios as informed by data (state) in the Gaia database. For example, you’re building an Autonomous Guided Vehicle (AGV) to move material around a warehouse. You can use Gaia’s database to model inventory and waypoint data so that your AGV can work without a direct connection to the internet. Throughout its mission, your AGV might generate lots of interesting and frankly uninteresting data. Use Gaia’s DB to store it for the moment and implement data fusion and filtering logic with Gaia policies. You can write a policy that throws away intermediate navigation data but retains any discoveries about the location of inventory. At the end of the mission, your AGV can sync back only what’s critical so that you can save on cloud bandwidth and storage costs. In systems in which pair Machine Learning (ML) and Deep Learning (DL) with perception and action planning methods, the Gaia Platform provides robust rules handling and event messaging to understand the data. What does this mean for Autonomous Systems? Autonomous Systems typically engage in a process of perceiving their environment, understanding an operational context, and acting accordingly. ML/DL is excellent at turning data into meaningful semantics, such as examining an RBG tensor and producing a label like \"kitty!\". To go from \"I see the kitty\" to \"I will pet the kitty\" requires additional layers of software to take the data from the perception engine and contextualize its output to make the decision. This is where Gaia comes in. Gaia allows you to define all the logic that contextualizes these inputs, understand the situation, and translate it into a decision. Based on the decision, Gaia can raise an event that sends an instruction to the robotic arm to pet the kitty. Beyond applications in Autonomous Systems, Gaia provides an Industrial strength transactional store that supports a transactionally safe framework. Whatever happens, you will always have a consistent database from which you can share data and act on it robustly. How it works Gaia is a platform in the sense that users build their applications on top of its functionality. Gaia runs on the Linux operating system and supports C++ and (soon) Python programming languages with declarative functionality. Gaia's in-memory database is installed with the platform and enables seamless integration between database operations and application control code. The Gaia Platform consists of the following elements: A shared in memory database An events engine A Catalog that interfaces with your app, the events engine, and the database And provides the following tools: Gaia Catalog compiler. The catalog compiler creates the datastore and tables that support your application. It also translates Gaia DDL files into the Gaia headers you include in your ruleset and app code files. For more information, see Gaiac and DDL . Gaia Translation Engine. The translation engine converts your rulesets into code files that you include in your app. These components and tools interact to create an end-to-end solution. To accomplish this, Gaia addresses the PUA paradigm: Perceive, Understand, and Act. In Gaia, this is expressed as: Perceive - Where inputs come from Understand - Gaia platform Act - Rules engine policies/ integration with devices Perceive Your procedural code gathers the data from the inputs and writes them the Gaia database. Gaia itself is not focused on direct control of the actions you take to control and read devices such as microcontrollers. This includes: Interrupt Processing Device Drivers Fine-grained manipulation of actuators Etc. The Database is Active. This means that it functions as an Event system that monitors the incoming changes to the database and publishes them for subscribed rules. The Gaia platform implements the database as an in memory high-performance data store. For more information about defining your Gaia database, see Gaiac and DDL . Understand The primary focus of rules is the Policy layer of applications. You define rules using easy-to-read and understand declarative code. The declarative code that defines a rule takes the form of \"If this happens, then do that.\" The rules engine and database work together to facilitate: Adaptive responses and process diversion resolution. For example, handle route diversion when a drone air taxi encounters bad weather. Data-driven decision-making. For example, Is this person allowed to be in that room at this hour. If you find edge cases where you need just a bit more control, you can intermix declarative code (rules) with procedural code. For more information about defining your rules, see Rules creation basics . Act Your code acts on the data and decisions produced by your rules. Gaia integrates with other platforms such as ROS2, including lower-level motion planning systems and other features to interact with your hardware. With Gaia, you can send a high-level instruction \"go to this waypoint\" to a ROS2 node that handles the task of navigating to that location. Summary Gaia provides a catalog that binds the database to the Gaia rules engine. Rules are written in declarative code and enable event-driven processing. The declarative code binds the rules to changes in the database without complex control flow logic. Next Steps Get started with the Gaia Platform Write your first Gaia App Learn the basics of creating rules"
  }
}